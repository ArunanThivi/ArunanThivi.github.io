<html>
<head>
  <title>Sorting</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="562"/>
<h1>Sorting</h1>

<div>
<span><div><div>Purposes of Sorting</div><ul><li><div>Sorting supports searching</div></li><li><div>Standard Example: Binary Search</div></li><li><div>Sorting supports other kinds of search</div></li><ul><li><div>Two equal items in the set?</div></li><li><div>Are there 2 items in the set with the same property?</div></li><li><div>What are my nearest neighbors?</div></li></ul><li><div>Sorting is used in numerous unexpected algorithms, (e.g. convex hull (smallest convex polygon enclosing set of points) )</div></li></ul><div>Some Definitions</div><ul><li><div>A <b>sorting algorithm</b> (or <b>sort</b>) <b>permutes</b> (re-arranges) a sequence of elements to brings them into order, accoring to some <b>total order</b>.</div></li><li><div>A total order is</div></li><ul><li><div>Total</div></li><li><div>Reflexive</div></li><li><div>Antisymmetric</div></li><li><div>Transitive:</div></li></ul><li><div>However, our orderings may treat unequal items as equivilent</div></li><ul><li><div>Ex: there can be 2 dictionary definitions for the same word. If we sort only by the word being defined (ignoring the definition), then sorting could put either entry first</div></li><li><div>A sort that does not change the relative order of equivilent entries (compared to the input) is called <b>stable</b></div></li></ul></ul><div>Classifications</div><ul><li><div><b>Internal sorts</b> keep all data in primary memory</div></li><li><div><b>External sorts</b> process large amounts of data in batches, keeping what won't fit in secondary storage</div></li><li><div><b>Comparison-based sorting</b> assumes only things we know about keys is their order</div></li><li><div><b>Radix sorting</b> uses more information about key structure</div></li><li><div><b>Insertion sorting</b> works by repeatedly inserting items at their appropriate positions in the sorted sequence being constructed.</div></li><li><div><b>Selection sorting</b> works by repeatedly selecting the next larger (or smaller) item in rder and adding it to one end of the sorted sequence being constructed.</div></li></ul><div>Sorting Arrays of Primitive Types in Java</div><ul><li><div>The java library provides static methods for sorting arrays in <u>java.util.Arrays</u>.</div></li><li><div>For primitive type P (other than boolean), there are the following methods to sort arrays</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** Sort all elements of ARR into non-descending order*/</div><div>static void sort(P[] arr) {...}</div><div><br/></div><div>/** Sort elements FIRST .. END - 1 of ARR into non-descending order */</div><div>static void sort(P[] arr, int first, int end) {...}</div><div><br/></div><div>static void parallelSort(P[] arr) {...}</div><div><br/></div><div>static void parallelSort(P[] arr, int first, int end) {...}</div></div><div><br/></div><div>Sorting Arrays of Reference Types in the Java Library</div><ul><li><div>For reference types, that have a <b>natural order</b> (implement <u>Java.lang.Comparable</u>), we have </div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** Sort all elements of ARR stably into non-descending order*/</div><div>static &lt;C extends Comparable&lt;? super C&gt;&gt; sort (C[] arr) {...}</div></div><ul><li><div>And for all reference types, R, we have four more</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** Sort all elements of ARR stably into non-descending order according to the ordering defined by COMP */</div><div>static &lt;R&gt; void sort(R[] arr, Comparator&lt;? super R&gt; comp) {...}</div></div><div>Sorting Lists in the Java library</div><ul><li><div>The class <u>java.util.Collections</u> contains 2 methods similar to the sorting methods for Arrays of Reference Types</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;C extends Comparable&lt;? Super C&gt;&gt; sort (List&lt;C&gt; lst) {..}</div><div><br/></div><div>static &lt;R&gt; void sort(List&lt;R&gt;, Comparator&lt;? super R&gt; comp) {...}</div></div><ul><li><div>Also an instance method in the List&lt;R&gt; interface itself</div></li></ul><div>Examples</div><ul><li><div>Sort X, a String[] or List&lt;String&gt; into non-descending order:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sort(X);</div></div><ul><li><div>Sort X into reverse order</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sort(X, (String x, String y) -&gt; {return y.compareTo(x); }); //or</div><div>sort(X, Collections.reverseOrder()); //or</div><div>X.sort(Collections.reverseOrder());</div></div><ul><li><div>Sort X[10], ... , X[100] in array or List X (rest unchanged):</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sort(X, 10, 101);</div></div><ul><li><div>sort L[10], ..., L[100] in list L (rest unchanged)</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>sort(L.sublist(10, 101);</div></div><div>Sorting by Insertion</div><ul><li><div>Simple Idea:</div></li><ul><li><div>Start with an empty sequence of outputs</div></li><li><div>Add each item from input, <b>inserting</b> into output sequence at the right point</div></li></ul><li><div>Very simple, good for <b>small</b> sets of data</div></li><li><div>With a vector/linked list, time for find + insertion of one item is (at worst) Θ(k) where k is # of outputs so far</div></li><li><div>This gives us a Θ(N<sup>2</sup>) algorithm (worst case as usual)</div></li></ul><div>Inversions</div><ul><li><div>Can run in Θ(N) comparisons if already sorted</div></li><li><div>Consider a typical implementation for arrays:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 1; i &lt; A.length; i++) {</div><div><span>    int j;</span><br/></div><div><span><span>    Object x = A[i];</span><br/></span></div><div><span><span>    for (j = i - 1; j &gt;= 0; j--) {</span><br/></span></div><div><span><span>    </span><span>    if (A[j].compareTo(x) &lt;= 0)</span><br/></span></div><div><span><span>    </span><span>    </span><span>    break;</span><br/></span></div><div><span><span>    </span><span>    A[j+1] = A[j];</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span><span>    A[j+1] = x;</span><br/></span></div><div><span>}</span></div></div><ul><li><div># of times (1) executes for each j = how far x must move</div></li><li><div>If all items are within K distance of their sorted place, then sorting takes <i>O</i>(KN) operations</div></li><li><div>So this is sort is good for any amount of <b>nearly sorted</b> data</div></li><li><div>One measure of unsortedness: # of <b>inversions</b>: pairs that are out of order (= 0 when sorted, N(N-1)/2 when reversed).</div></li><li><div>Each execution of (2) decreases inversions by 1</div></li></ul><div>Shell's sort</div><div><b>Idea</b>: Improve insertion sort by first sorting <b>distant</b> elements:</div><ul><li><div>First sort subsequences of elements 2<sup>k</sup> - 1 apart:</div></li><ul><li><div>Sort 0, 2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k</span> - 1, 2(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k</span> - 1), 3(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k</span> - 1), ...</div></li><li><div>Sort 1, 1+ 2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k</span> - 1, 1 + 2(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k</span> - 1), 1+ 3(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k</span> - 1) ...</div></li><li><div>etc.</div></li></ul><li><div>Then sort subsequences of elements 2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1 apart</div></li><ul><li><div>Sort items 0, 2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1, 2(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1), 3(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1), ... then</div></li><li><div>Sort items 1, 1+ 2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1, 1+ 2(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1), 1+ 3(2<span style="vertical-align: super; font-size: smaller; font-size: smaller;">k-1</span> - 1), ....</div></li></ul><li><div>End of plain insertion sort (2<sup>0</sup> = 1 apart), but with most inversions gone</div></li><li><div>Sort is Θ(N<sup>3/2</sup>)</div></li><li><div><br/></div></li></ul><div><br/></div></div></span>
</div></body></html> 