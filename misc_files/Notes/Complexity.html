<html>
<head>
  <title>Complexity</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="530"/>
<h1>Complexity</h1>

<div>
<span><div><div><font style="font-size: 16pt;">Cost</font></div><ul><li><div>Cost is a principal concern throughout engineering:</div></li><li><div>Cost can mean many things</div></li><ul><li><div>Operational Cost (time to run a program, space requirements)</div></li><li><div>Development Costs: How long does it take to make</div></li><li><div>Maintenance costs: Time costs of bug fixes, upgrading features</div></li><li><div>Costs of failure: How robust is the software? How safe is it?</div></li></ul><li><div>How fast is fast enough?</div></li><ul><li><div>For what purpose?</div></li><li><div>For what input data?</div></li></ul><li><div>How much space is required? (Memory and disk space)</div></li><ul><li><div>Depends on input data</div></li></ul><li><div>How will it scale, as input gets big?</div></li></ul><div><font style="font-size: 16pt;">Cost Measures (Time)</font></div><ul><li><div>Wall-clock or execution time</div></li><ul><li><div>You can do this at home (time java FindPrimes 1000)</div></li><li><div>Pros: easy to measure, meaning is obvious</div></li><li><div>Cons: Only applies to the specific conditions program was run in (data set, compiler, machine etc.)</div></li><li><div>Appropriate where time is critical (e.g. real-time systems like computer in car)</div></li></ul><li><div>Dynamic statement counts</div></li><ul><li><div>Count of # of times statements are executed:</div></li><li><div>Pros: More general (not sensitive to the speed of the machine)</div></li><li><div>Cons: Does not tell you actual time, still only applies to specific data sets</div></li></ul><li><div>Symbolic execution times</div></li><ul><li><div>Formulas for execution times as functions of input size</div></li><li><div>Pros: Applies to all inputs, makes scaling easier</div></li><li><div>Cons: Practical formula must be approximate, may tell very little about actual time</div></li></ul></ul><div><font style="font-size: 16pt;">Asymptotic Cost</font></div><ul><li><div>Symbolic execution times lets us see the shape of the cost function</div></li><li><div>Since this is all just approximations, precision is meaningless to an extent</div></li><ul><li><div>Behavior on small inputs</div></li><ul><li><div>Small inputs differ minimally in run time</div></li><li><div>Can always pre-calculate some results</div></li><li><div>asymptotic behavior has input size becomes very large is more practical</div></li></ul><li><div>Constant Factors</div></li><ul><li><div>Using a different machine changes the constant-factor</div></li></ul></ul></ul><div><font style="font-size: 16pt;">Order Notation</font></div><ul><li><div>Instead of specific functions that specify size, rather create families of functions with simliarly behaved magnitudes</div></li><li><div>Then say &quot;f is bounded by g if it is in g's family&quot;</div></li><li><div>For any function g(x), the functions 2g(x), 0.5g(x), or g(x) * any constant multiplier , all have the same shape, so they are all a part of g's family</div></li><li><div>Any function h(x) such that h(x) = K * g(x) for x &gt; M (some constant) has g's shape &quot;except for small values&quot; So these are all in g's family</div></li><li><div>For upper limits, all functions whose absolute value is everywhere &lt;= some member of g's family, this is the set O(g) or O(g(x))</div></li><li><div>For lower limits, all functions whose absolute value is everywhere &gt;= some member of g's family, this is the set Ω(g)</div></li><li><div>Define Θ(g) = O(g) ∩ Ω(g) - the set of functions bracketed in magnitude by two members of g's family</div></li></ul><div><br/></div><div><img src="Complexity_files/Image.png" type="image/png" data-filename="Image.png" width="229"/> </div><ul><li><div>Here, f(x) &lt;= 2g(x) as long as x &gt; 1, so f(x) ⋲ O(g(x))</div></li><li><div>Also (in this case), f(x) &gt;= g(x) for all values of x, so f(x) ⋲ Ω(g(x))</div></li></ul><div><br/></div><div>All factors except for the largest factor become trivialized, so only the largest factor is important in determining the runtime of a function</div><div><font style="font-size: 16pt;">Using Order Notation</font></div><ul><li><div>We can use this order notation for any kind of real-valued function</div></li></ul><div><font style="font-size: 14pt;">Example</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** Find position of X in list L, or -1 if not found. */</div><div>int find(List L, Object X) {</div><div>    int c;</div><div>    for (c = 0; L != null; L = L.next, c++)</div><div>        if (X.equals(L.head)) return c;</div><div>    return -1;</div><div>}</div></div><ul><li><div>Choose a representative operation (i.e. The number of calls to .equals())</div></li><li><div>For a list of length N, .equals() is called, in a worst-case scenario, N times</div></li><li><div>Total # of instructions executed is proportional to the length of the list, so worst-case time is O(N), regardless of units</div></li><li><div>The worst case time is ALSO O(N2) since N ⋲ O(N2)</div></li><li><div>The worst case time is Ω(N), since N ⋲ Ω(N), </div></li><li><div>Because the worst case time is both Ω(N) and O(N), we can say that the function has a Θ bound: Θ(N)</div></li><li><div>Best-case time: Θ(1) (Number is found at the beginning of the loop)</div></li></ul><div><font style="font-size: 16pt;">Nested Loops</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0; i &lt; A.length; i++) {</div><div>    for (int j = 0; j &lt; A.length; j++) {</div><div>        if (i != j &amp;&amp; A[i] == A[j])</div><div>            return true;</div><div>return false</div></div><ul><li><div>Here, time is O(N2), where N = A.length. Worst-case time is Θ(N2)</div></li></ul><div><font style="font-size: 14pt;">A more efficient example</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0; i &lt; A.length; i++)</div><div>    for (int j = i + 1; j &lt; A.length; j++)</div><div>        if (A[i] == A[j]) return true;</div><div>return false;</div></div><ul><li><div>Now, worst case time is proportional to (N-1) + (N-2) + ... + 1 = N(N-1)/2 ⋲ Θ(N2)</div></li><ul><li><div>Asymptotic time does not change by the constant factor</div></li></ul></ul><div><font style="font-size: 16pt;">Recursion and Recurrances: Fast Growth</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>boolean occurs (String S, String X) {</div><div>    if (S.equals(X)) return true;</div><div>    if (S.length() &lt;= X.length()) return false;</div><div>    return</div><div>        occurs(S.substring(1), X) ||</div><div>        occurs(S.substring(0, S.length()-1), X);</div></div><ul><li><div>Worst-case cost of occurs(S, X) grows exponentially ⋲ Θ(2n)</div></li><ul><li><div>Because the list is traversed forwards and backwards in separate recursive calls</div></li></ul></ul><div><font style="font-size: 16pt;">Binary Search: Slow Growth</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>boolean isIn(String X, String[] S, int L, int U) {</div><div>    if (L &gt; U) return false;</div><div>    int M = (L+U)/2;</div><div>    int direct = X.compareTo(S[M]);</div><div>    if (direct &lt; 0) return isIn(X, S, L, M-1);</div><div>    else if (direct &gt; 0) return isIn(X, S, M+1, U);</div><div>    return true;</div></div><ul><li><div>With every recursive call, the list is cut in half, so function is ⋲ Θ(log n)</div></li></ul><div><font style="font-size: 16pt;">Merge Sort</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>List sort(List L) {</div><div>    if (L.length() &lt; 2) return L;</div><div>    //Split L into L0 and L1 of about equal size</div><div>    L0 = sort(L0); L1 = sort(L1);</div><div>    //return merge of L0 and L1</div></div><ul><li><div>In general, this function is <i>Θ(N log N)</i></div></li><ul><li><div>Every call creates another additional factor of +N (from the merge) and cuts N in half</div></li></ul></ul><div><br/></div></div></span>
</div></body></html> 