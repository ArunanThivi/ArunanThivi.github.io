<html>
<head>
  <title>Hashing</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="528"/>
<h1>Hashing</h1>

<div>
<span><div><div><span style="font-size: 16pt;">Hashing</span></div><ul><li><div>Linear search is okay for small data sets, getrs worse as size of data set increases (time is proportional to size)</div></li><li><div>Suppose that we could put a small number of keys into a lot of  <span style="font-style: italic;">'buckets'</span> so each bucket has the same amount of keys</div></li><ul><li><div>Then searching just becomes finding the right bucket and finding the right key within the bucket</div></li><li><div>This allows the search to be done in <span style="font-weight: bold;">constant time</span></div></li></ul><li><div>To do this, we must have a way to find which bucket a key is in (if the item is present): a <span style="font-weight: bold;">hashing function</span></div></li><ul><li><div>If the function returns a bucket that does NOT contain the key, then the key is NOT FOUND in the data set</div></li></ul></ul><div><span style="font-size: 14pt; text-decoration: underline;">Example</span><span style="font-size: 14pt;">: </span></div><ul><li><div>N = 200 data items</div></li><li><div>keys are <span style="text-decoration: underline;">longs</span> evenly spread over the range 0..2<span style="vertical-align: super;">63</span> -1</div></li><li><div>Want to keep maximum search to L = 2 items</div></li><li><div>hash function h(K) = K%M where M = N/L = 100 is the number of buckets</div></li><ul><li><div>100232, 433, and 10002332482 go into different buckets (32, 33, 82 respectively)</div></li><li><div>10, 400210, and 210 all go into the same bucket (10)</div></li></ul><li><div>Create an array of M buckets</div></li><ul><li><div>Each bucket is a list of data items (E.g. [300, 100, 1500])</div></li></ul><li><div>Not all buckets have same length, but average length is N/M = L, the <span style="font-weight: bold;">load factor</span></div></li><ul><li><div>This smooths out the distribution, so no bucket gets too large</div></li></ul><li><div>To work well, the hash function must avoid <span style="font-weight: bold;">collisions</span>: separate keys that &quot;hash&quot; to the same values</div></li></ul><div><span style="font-size: 16pt;">Open Address Hashing</span></div><ul><li><div>Idea: one one data item in each bucket</div></li><li><div>When there is a collision and a bucket is full, just make another bucket</div></li><li><div>Ways to do this:</div></li><ul><li><div>Linear probes: If there is a collision at h(K), try h(K)+m, h(K) + 2m, etc. (wrap around at end)</div></li><li><div>Quadratic probes: h(K) +m<span style="vertical-align: super; font-size: smaller; font-size: smaller;">2</span>, h(K) + 2m<span style="vertical-align: super;">2</span></div></li><li><div>Double Hashing: h(K) + h'(K), h(K) + 2h'(K), etc.</div></li></ul><li><div>Things can get slow, even when there are a lot of empty spaces in the table</div></li><ul><li><div>Function may have to make MULTIPLE searches in order to find an available spot in the table</div></li><li><div>Table takes more time to parse the closer it gets to full</div></li></ul></ul><div><span style="font-size: 16pt;">Filling the Table</span></div><ul><li><div>To get constant-time, the number of buckets must be within a constant factor of the number of items</div></li><li><div>So we must resize the table when the load factor gets bigger than some limit</div></li><ul><li><div>Increasing the number of buckets changes the hash function, so everything must move to a new location</div></li></ul><li><div>In order to expand the Hashtable, you must expand the array AND re-hash all the existing items</div></li><li><div>Doubling the table size each time gets constant <span style="font-weight: bold;">amortized</span> time for insertion and lookup (Assuming a good hash function)</div></li></ul><div><span style="font-size: 16pt;">Hash Functions: Strings</span></div><ul><li><div>For strings, a good hash function takes ALL characters and their positions into account</div></li><li><div>s<span style="vertical-align: sub;">0</span> + s<span style="vertical-align: sub;">1</span> + ... + s<span style="vertical-align: sub;">n-1</span> does not take POSITION into account, multiple permutations will end with the same sum</div></li><li><div>For strings, Java uses:</div></li></ul><div style="margin-left: 80px;">h(s) = s<span style="vertical-align: sub;">0</span> * 31<span style="vertical-align: super;">n-1</span> * s<span style="vertical-align: sub; font-size: smaller; font-size: smaller;">0</span>+ 31<span style="vertical-align: super;">n-2</span> * s<span style="vertical-align: sub;">1</span> + ...+ s<span style="vertical-align: sub;">n-1</span> computed modulo 2<span style="vertical-align: super;">32</span> as in java int arithmethic</div><div><span style="font-size: 16pt;">Hash Functions: Other Data Structures I</span></div><ul><li><div>Lists (ArrayList, LinkedList, etc.) are analogous to strings, Java uses</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>hashCode = 1; Iterator i = list.iterator();</div><div>while (i.hasNext()) {</div><div>    Object obj = i.hext();</div><div>    hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode());</div><div>}</div></div><div>Every Object has a .hashCode() method which returns its hashCode</div><ul><li><div>Can limit time spent computing hash function by not looking at the entire list</div></li><ul><li><div>Example: look at only the first few items (if dealing with a List or a SortedSet)</div></li></ul><li><div>Causes more collisions, but does <span style="font-weight: bold;">not</span> allow for equal things to go into different buckets</div></li></ul><div><span style="font-size: 16pt;">Hash Functions: Other Data Structures II</span></div><ul><li><div>Recursively defined data structures -&gt; recursively defined hash functions</div></li><li><div>Example: For a binary tree, one can use something like</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>hash (T):</div><div>    if (T == null)</div><div>        return 0</div><div>    else</div><div>        return someHashFunction(T.label()) ^ hash(T.left()) ^ hash(T.right());</div></div><div><br/></div><ul><li><div>By default, Java uses memory addresses of objects to create hash codes (identity hash function)</div></li><li><div>Objects are NEVER considered equal</div></li><li><div>Be Careful!!! This <span style="font-weight: bold;">will not</span> work on Strings, because equal Strings could be in different buckets: (String class <span style="font-weight: bold;">overrides</span> .equals() method)</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>String H = 'Hello',</div><div>        S1 = H + ', world',</div><div>        S2 = 'Hello, world!';</div></div><ul><li><div>Here, S1.equals(S2) returns <span style="font-weight: bold;">true</span> but S1 == S2 returns <span style="font-weight: bold;">false</span></div></li></ul><div><br/></div><div>The types Hashtable, HashSet, and HashMap use hashCode to give you fast lookup of Objects.</div><ul><li><div>map.put (key, value)              Map KEY -&gt; VALUE</div></li><li><div>map.get(someKey)                 VALUE last mapped to by SOMEKEY</div></li><li><div>map.containsKey(someKey)   Is SOMEKEY mapped?</div></li><li><div>map.keySet()                          All keys in MAP (a Set)</div></li></ul><div><br/></div><div><span style="font-size: 16pt;">Special Case: Monotonic Hash functions</span></div><ul><li><div>Suppose our hash function is monotonic: either nonincreasing or nondecreasing (If k<span style="vertical-align: sub;">1</span> &gt; k<span style="vertical-align: sub;">2</span> then h(k<span style="vertical-align: sub;">1</span>) &gt;= h(k<span style="vertical-align: sub;">2</span>)</div></li><ul><li><div>Example: Items are time-stamped records where the key is the time, The hashing function creates one bucket every hour</div></li></ul><li><div>This makes range queries faster as we can just search the buckets within the range</div></li></ul><div><span style="font-size: 16pt;">Perfect Hashing</span></div><ul><li><div>Suppose the set of keys is <span style="font-weight: bold;">fixed</span></div></li><li><div>A tailor-made hash function might high every key to a different value: <span style="font-weight: bold;">perfect hashing</span></div></li><li><div>In this case, there is no search along a chain or in an open-address table: either the element at the hash value is or is not equal to the target key</div></li><li><div>Ex: one might use the first, middle, and last letters of a string. This would work if those letters differ among all strings in the set</div></li><li><div>Or one must use the Java method, but tweak the multipliers until all strings gave different results</div></li></ul><div><span style="font-size: 16pt;">Characteristics</span></div><ul><li><div>Assuming good hash function, add, lookup, and deletion take <span style="font-weight: bold;">constant</span> time, amortized</div></li><li><div>Good for cases where one looks up <span style="font-weight: bold;">equal</span> keys</div></li><li><div>Usually bad for range queries</div></li><li><div>Probably not a good idea for small sets that one can rapidly create and discard (Lots of unnecessary overhead)</div></li></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 