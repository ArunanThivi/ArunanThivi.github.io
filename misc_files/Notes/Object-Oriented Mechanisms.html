<html>
<head>
  <title>Object-Oriented Mechanisms</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="520"/>
<h1>Object-Oriented Mechanisms</h1>

<div>
<span><div><div>Today's Lecture:</div><ul><li><div>The bare mechanics of &quot;object-oriented programming&quot;</div></li><li><div>The general topic is: <span style="text-decoration: underline;">Writing software that operates on many kinds of data</span></div></li></ul><hr/><div><font style="font-size: 14pt;">Overloading</font></div><div style="margin-left: 40px;"></div><div>Problem: How to get System.out.print(x) to print x regardless of type?</div><ul><li><div>In Scheme/Python, one function can take an argument of any type, and then test the type (if necessary)</div></li><li><div>In Java, methods specify a <span style="font-weight: bold;">single</span> <span style="font-weight: bold;">type</span> of arguement</div></li><li><div>Partial solution: <span style="font-weight: bold;">Overloading</span> - multiple method definitions with the same name and different numbers of types of arguments</div></li></ul><div><font style="font-size: 14pt;">Generic Data Structures</font></div><div>Problem: How to get a &quot;list of anything&quot; or an &quot;array of anything&quot;?</div><div>Easy in Scheme/Python</div><div>In Java, lists (like IntList) and arrays have a single type of element</div><div style="margin-left: 40px;"><span style="text-decoration: underline;">Short Answer</span>: we can use java.lang.Object as a &quot;generic (reference) type&quot;</div><div>Primitive values (ints, longs, bytes, shorts, floats, doubles, chars, and bools) are <span style="font-weight: bold;">not</span> can't be converted to java.lang.Object</div><div>We can create new wrapper objects for any value (<span style="font-weight: bold;">boxing</span>)</div><div>Integer Three = new Integer(3);</div><div>Object ThreeObj = Three;</div><div>and vice versa (<span style="font-weight: bold;">unboxing</span>)</div><div>int three = Three.intValue();</div><div><font style="font-size: 14pt;">Dynamic vs Static Typing</font></div><ul><li><div>Every <span style="font-weight: bold;">value</span> has a type - it's <span style="font-weight: bold;">dynamic</span> type</div></li><li><div>Every <span style="font-weight: bold;">container</span>, literal, function call, and operator expression (x+y) has a type - it's <span style="font-weight: bold;">static</span> type</div></li><ul><li><div>Every <span style="font-weight: bold;">expression</span> has a <b>static</b> type</div></li></ul></ul><div><font style="font-size: 14pt;">Type Heirarchies<br/></font></div><ul><li><div>A container with <b>(static)</b> type T may contain a value ONLY if it's value has a <b>dynamic</b> type that is a <b>sub-type</b> of T</div></li><li><div>Likewise, a function of return type T may return ONLY values of sub-type T</div></li><li><div>All types are subtypes of themselves (and nothing else for primitives)</div></li><li><div><b>Reference types</b> form a <b>type hierarchy</b>: some are subtypes of others</div></li><ul><li><div><b>null</b> is a subtype of ALL reference types</div></li><li><div>ALL reference types are subtypes of java.lang.Object;</div></li></ul></ul><div><font style="font-size: 14pt;">The Basic Static Type Rule</font></div><ul><li><div>Java is designed so that any expression of (static) type T ALWAYS yields a value that is a sub-type of T</div></li><li><div>Static types are &quot;known to the compiler&quot;, because you declare them</div></li><ul><li><div>Ex: String x;, int f(Object s) { int y; }</div></li></ul><li><div>Compiler insists that in an assignment, L = E, or a function call f{E), where void f(Sometype L) { ... }, E's <b>static</b> type must be a <b>subtype</b> of L's static type</div></li><ul><li><div>Similar rules apply to arrays and other built-in operations</div></li></ul></ul><div><font style="font-size: 14pt;">Coercions</font></div><ul><li><div>For example: The values of type <u>short</u> are a subset of those of <u>int</u> (<u>short</u> is 16-bit, <u>int</u> is 32-bit integer)</div></li><li><div>But <u>short</u> is NOT a subtype of <u>int</u>, because they behave differently</div></li><li><div>Instead, we say that <u>short</u> can be <b>coerced</b> (converted) to a value of type <u>int</u></div></li></ul><div>You may ONLY use methods of the <b>STATIC </b>type of the object, dynamic type is irrelevant</div><div><font style="font-size: 14pt;">Override toString<br/></font></div><ul><li><div>The toString() method typically gives useless information like the Memory address of the Object</div></li><li><div>We can <b>override</b> the toString() method to supply our own String representation of an Object</div></li><li><div>The '+' operator on strings calls .toString() when asked to append an Object</div></li></ul><div>Example toString() for IntList</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class IntList {</div><div><span>    public String toString() {</span><br/></div><div><span><span>    </span><span>    StringBuffer b = new StringBuffer();</span><br/></span></div><div><span><span>    </span><span>    b.append(&quot;L&quot;);</span><br/></span></div><div><span><span>    </span><span>    for (IntList L = this; L != null; L = L.tail) {</span><br/></span></div><div><span><span>    </span><span>    </span><span>    b.append(&quot; &quot; + L.head);</span><br/></span></div><div><span><span>    </span><span>    b.append(&quot;]&quot;);;</span><br/></span></div><div><span><span>    </span><span>    return b.toString();</span><br/></span></div><div><span><span>    }</span><br/></span></div></div><div><font style="font-size: 14pt;">Extending a Class</font></div><ul><li><div>To say that class <u>B</u> is a direct subtype of class A (or A is a direct <b>superclass</b> of B), we write:</div></li><ul><li><div>class B <b>extends</b> A { ... }</div></li></ul><li><div>By default, every class extends java.lang.Object</div></li><li><div>The subtype <b>inherits</b> all fields and methods of its direct superclass (and passes them along to any of its subtypes)</div></li><li><div>In class B, you can <b>override</b> an instance method (<b>NOT STATIC METHODS</b>), by providing a new definition with the same <b>signature</b> (name, return type, arguement types).</div></li></ul><div><font style="font-size: 12pt;">REMINDER:</font></div><ul><li><div>For instance methods (only) select methods based on dynamic type. Simple to state, but we'll see it has profound consequences</div></li><li><div>Fields hide inherited fields of same name; static methods hide methods of the same signature</div></li></ul><div><font style="font-size: 14pt;">What's the Point?</font></div><ul><li><div>This mechanism allows us to define a kind of generic method</div></li><li><div>A <span style="font-weight: bold;">superclass</span> can define a set of methods that are common to many different classes</div></li><li><div><span style="font-weight: bold;">Subclasses</span> can then provide different implementations of these common methods, each specialized in some way</div></li><li><div>All subclasses will have <span style="text-decoration: underline;">at least</span> the methods listed by the superclass</div></li><li><div>So when we write methods that operate on a superclass, they will automatically work for all its subclasses.</div></li></ul></div><div><br/></div></span>
</div></body></html> 