<html>
<head>
  <title>Priority Queues, Range Queries</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="554"/>
<h1>Priority Queues, Range Queries</h1>

<div>
<span><div><div><font style="font-size: 16pt;">Priority Queues, Heaps</font></div><ul><li><div>&quot;A priority queue is an abstract idea, a Heap is a specific implementation of that idea</div></li><li><div><b>Priority Queue</b>:  define by operations &quot;add&quot;, &quot;find largest&quot;, &quot;remove largest&quot;</div></li><li><div>Examples: Scheduling long streams of actions to occur at various future times</div></li><li><div>Also useful for sorting (keep removing largest item)</div></li><li><div>Common Implementation is the <b>heap</b>, a kind of tree</div></li></ul><div><font style="font-size: 16pt;">Heap</font></div><ul><li><div>A <b>max-heap</b> is a binary tree that enforces the</div></li><ul><li><div><b>Heap property:</b> Labels of <b>both</b> children of each node are less than node's label</div></li></ul><li><div>So <b>node at the top</b> has the <b>largest label</b></div></li><li><div>Looser than binary search property, which allows us to keep tree &quot;bushy&quot;</div></li><li><div>That is, it's always valid to put the smallest nodes anywhere at the bottom of the tree</div></li><li><div>Thus, heaps can be made <b>nearly complete:</b> all but possibly the last row have as many keys as possible</div></li><li><div>As a result, insertion of new value and deletion of largest value in worst case take time proportional to log <i>N</i> (or height of tree)</div></li><li><div>A <b>min-heap</b> is basically the same, but with the minimum value at the root and children having larger values than their parents</div></li></ul><div><font style="font-size: 16pt;">Adding value to Heap</font></div><ol><li><div>Add a node to the next available spot in the bottom level of the heap</div></li><li><div>If the heap violates the heap property, swap node with its parent</div></li><li><div>Repeat step 2 until Heap Property is restored</div></li></ol><div><font style="font-size: 16pt;">Removing largest value from Heap</font></div><ol><li><div>Swap top node with bottom-most, rightmost node</div></li><li><div>Remove the bottom-most rightmost node (formerly the root)</div></li><li><div>If the heap violates the heap property, swap the new root node with the largest of its children</div></li><li><div>Continue swapping down the heap until heap property is restored</div></li></ol><div><font style="font-size: 16pt;">Heaps in Arrays</font></div><ul><li><div>Since heaps are nearly complete (missing only items at the bottom level), we can use arrays for compact representation</div></li><li><div>Start at index 1 (makes arithmetic simpler)</div></li><li><div>Left child of node at index <i>i</i>  is at index 2<i>i</i></div></li><li><div>Right child of node at index <i>i</i> is at index 2<i>i</i> + 1</div></li><li><div>If 2i &gt; Size of array, the node has no children</div></li><li><div>Heap operations work exactly as before</div></li></ul><div><font style="font-size: 16pt;">Ranges</font></div><ul><li><div>So far, we have looked for specific items</div></li><li><div>But BSTs can also support looking for <b>ranges of values</b></div></li><li><div>Example: Perform some action on all values in a BST that are within some range (in natural order)</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static void visitRange(BST&lt;String&gt; T, String L, String U, Consumer&lt;BST&lt;String&gt;&gt; whatToDo) {</div><div><span>    if (T != null) {</span><br/></div><div><span><span>   <span>    </span> int compLeft = L.compareTo(T.label()), compRight = U.compareTo(T.label());</span><br/></span></div><div><span><span>   <span>    </span> if (compLeft &lt; 0)<span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    //L &lt; Label</span></span><br/></span></div><div><span><span>    </span><span>   <span>    </span> visitRange(T.left(), L, U, whatToDo);</span><br/></span></div><div><span><span>    <span>    </span>if (compLeft &lt;= 0 &amp;&amp; compRight &gt; 0)<span>    </span><span>    </span><span>  //L &lt;= Label &lt;= U</span></span><br/></span></div><div><span><span>    </span><span>   <span>    </span> whatToDo.accept(T);</span><br/></span></div><div><span><span>    <span>    </span>if (compRight &gt; 0)</span><br/></span></div><div><span><span>    </span><span>    <span>    </span>visitRange(T.right(), L, U, whatToDo);<span>   // Label &lt; U</span></span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span>}</span></div></div><div><br/></div><div><font style="font-size: 16pt;">Tie for Range Queries</font></div><ul><li><div>Time for Range Query ⋲<i>O</i>(<i>h</i> + <i>M</i>), where <i>h</i> is height of tree, and <i>M</i> is number of data items that turn out to be in the range</div></li></ul><div><font style="font-size: 16pt;">Ordered Sets and Range Queries in Java</font></div><ul><li><div>Class <u>SortedSet</u> supports range queries with <i>views</i> of set:</div></li><ul><li><div>S.headSet(U): subset of S that is &lt; U</div></li><li><div>S.tailSet(L): subset that is &gt;= L</div></li><li><div>S.subSet(L, U): subset that is &gt;= L AND &lt; U</div></li></ul><li><div>Changes to views modify S</div></li><li><div>Attempts to (e.g. add a headSet beyond U are <b>disallowed</b></div></li><li><div>Can iterate through a view to process a range</div></li></ul><div><font style="font-size: 16pt;">TreeSet</font></div><ul><li><div><font style="font-size: 10pt;">Java library type TreeSet&lt;T&gt; requires either that T be <b>Comparable</b>, or that you provide a Comparator, as in</font></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>SortedSet&lt;String&gt; rev_fauna = new TreeSet&lt;String&gt;(Collections.reverseOrder());</div></div><ul><li><div>Comparator is a type of function object</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>interface Comparator&lt;T&gt; {</div><div><span>    /** Return &lt;0 if LEFT &lt; RIGHT, &gt;0 if LEFT &gt; RIGHT, else 0 */</span><br/></div><div><span><span>    int compare(T left, T right);</span><br/></span></div><div><span>}</span></div></div><ul><li><div>Example: reverseOrder comparator is defined like this:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T extends Comparable&lt;T&gt;&gt; Comparator &lt;T&gt; reverseOrder() {</div><div><span>    return (x, y) -&gt; y.compareTo(x);   //Java understands that this lambda expression is a Comparable&lt;T&gt;</span><br/></div></div><div><br/></div></div></span>
</div></body></html> 