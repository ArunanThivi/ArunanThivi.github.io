<html>
<head>
  <title>Generics</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="556"/>
<h1>Generics</h1>

<div>
<span><div><div>The Old Days</div><ul><li><div>Java library types (such as <u>List</u>) didn't used to parameterized. All <u>List</u>s were lists of <u>Object</u>s</div></li><li><div>So you'd write things like</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0; i &lt; L.size(); i++)</div><div><span>    { String s = (String) L.get(i); ...}</span><br/></div></div><ul><li><div>Every Object must be casted so the compiler knows exactly what it is</div></li><li><div>Also, when calling L.add(), there was no check to make sure the parameter was of a valid type</div></li><li><div>Starting with Java 1.5, designers alleviated this problem by introducing <b>parameterized types</b>, like List&lt;String&gt;</div></li></ul><div>Basic Parameterization</div><ul><li><div>From the definitions of ArrayList and Map in java.util</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class ArrayList&lt;Item&gt; implements List&lt;Item&gt; {</div><div><span>    public Item get(int i) {...}</span><br/></div><div><span><span>    public boolean add(Item x) {...}</span><br/></span></div><div><span><span>    ...</span><br/></span></div><div><span>}</span></div><div><span>public interface Map&lt;Key, Value&gt; {</span></div><div><span><span>    Value get(Key x);</span><br/></span></div><div><span><span>    ...</span><br/></span></div><div><span>}</span></div></div><ul><li><div>Substitute &quot;Item, Key, and Value&quot; in the functions with the type defined when the object is created</div></li></ul><div>Type Instantiation</div><ul><li><div><b>Instantiating</b> a generic type is analogous to calling a function</div></li><li><div>Consider the ArrayList example from above</div></li><ul><li><div>When we write ArrayList&lt;String&gt; we, in effect, get a new type like</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public String_ArrayList implements List&lt;String&gt; {</div><div><span>    public String get(int i) {...}</span><br/></div><div><span><span>    public boolean add(String x) {...}</span><br/></span></div></div><ul><ul><li><div>Likewise, List&lt;String&gt; refers to a new interface type as well</div></li></ul></ul><div>Parameters on Methods</div><ul><li><div>Functions may ALSO be parameterized by type</div></li><ul><li><div>Example:</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T&gt; List &lt;T&gt; singleton(T item) {...}</div><div>static &lt;T&gt; List&lt;T&gt; emptyList() {...}</div></div><ul><li><div>The compiler figures out <i>T</i> in the expression singleton(x) by looking up the type of <i>x</i>. This is a simple example of <b>type inference</b></div></li></ul><div>Wildcards</div><ul><li><div>Consider the definition of something that counts the number of tmes something ocurs in a collection of items</div></li><li><div>Could be written as:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T&gt; int frequency(Colelction&lt;T&gt; c, Object x) {</div><div><span>    int n = 0;</span><br/></div><div><span><span>    for (T y: c) {</span><br/></span></div><div><span><span>    </span><span>    if (x.equals(y))</span><br/></span></div><div><span><span>    </span><span>    </span><span>    n ++;</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span><span>    return n;</span><br/></span></div><div><span>}</span></div></div><ul><li><div>But we really don't care about what <i>T</i> is, so we could just write</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (Object y : c) {</div></div><ul><li><div><b>Wildcard type parameters</b> say that you don't care about what type a parameter is (i.e. it's any subtype of Object)</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int frequency(Collection&lt;?&gt; c, Object x) { ... }</div></div><div>Subtyping</div><ul><li><div>Consider:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>List&lt;String&gt; LS = new ArrayList&lt;String&gt;();</div><div>List&lt;Object&gt; LObj = LS;</div><div>int[] A = {1, 2};</div><div>LObj.add(A);</div><div>String S = LS.get(0);</div></div><ul><li><div>These commands violate <b>type safety</b>: the compiler is wrong about the type of a value (an int is in place of a String)</div></li><li><div>For T1&lt;X&gt; to be a subtype of T2&lt;Y&gt;, X == Y</div></li></ul><div>What about the relationship between T1 and T2?</div><ul><li><div>Consider:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ArrayList&lt;String&gt; ALS = new ArrayList&lt;String&gt;();</div><div>List&lt;String&gt; LS= ALS;</div></div><ul><li><div>Here, everything is fine</div></li><ul><li><div>The object's dynamic type is ArrayList&lt;String&gt;</div></li><li><div>Thus, the methods expected for LS must be a subset of those for ALS</div></li><li><div>Since the type parameters are the same, the signatures of the methods will be the same</div></li><li><div>Thus, all legal calls on methods of LS will be valid for the actual object pointed to by LS</div></li></ul><li><div>In general, T1&lt;X&gt; is a subtype of T2&lt;X&gt; if T1 is a subtype of T2</div></li></ul><div>A Java Inconsistency: Arrays</div><ul><li><div>As shown above, ArrayList&lt;String&gt; is <b>not</b> a subtype of ArrayList&lt;Object&gt;, so it is to be expected that String[] is <b>not</b> a subtype of Object[]</div></li><li><div>However, Java <b>does</b> have String[] be a subtype of Object[]</div></li><li><div>Java encounters an error like above, it throws a ArrayStoreException (a runtime error) instead of a compile-time error</div></li><li><div>This is done so things like <u>ArrayList</u> can be implemented</div></li></ul><div>Type Bounds</div><ul><li><div>Sometimes, the program needs to ensure that a particular type parameters is replaced only by a subtype (or supertype) of a particular type (sort of like specifying the &quot;type of a type&quot;)</div></li><li><div>Example</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class NumericSet&lt;T extends Number&gt; extends HashSet&lt;T&gt; {</div><div><span>    T min() { ... }</span><br/></div><div><span><span>    ...</span><br/></span></div><div><span>}</span></div></div><div style="margin-left: 40px;">Requires that all type parameters to NumericSet must be subtypes of Number (the &quot;type bound&quot;). T can either extend or implement the bound as appropriate</div><ul><li><div>Another example</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T&gt; void fill(List&lt;? super T&gt; L, T x) { ... }</div></div><div style="margin-left: 40px;">means that L can be a List&lt;Q&gt; for any Q as long as T is a subtype of (extends or implements) Q</div><ul><li><div>One more example</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** Search sorted list L for KEY, returning either its position (if present) or k-1, where KEY should be inserted*/</div><div>static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; L, T key)</div></div><ul><li><div>Here, the items of L have to have a type that is comparable to T's, or to have some super-type of T</div></li></ul><div>Secrets behind the Scenes</div><ul><li><div>When you write</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Foo&lt;T&gt; {</div><div><span>    T x;</span><br/></div><div><span><span>    T.mogrify (T y) { ..}</span><br/></span></div><div><span>}</span></div></div><div style="margin-left: 40px;">Java is really just giving you</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Foo {</div><div><span>    Object x;</span><br/></div><div><span><span>    Object mogrify (Object y) { ... }</span><br/></span></div></div><ul><li><div>When you use Generics, Java supplies the casts automatically, and also throws in some additional checks. If it cannot guarantee that all those casts will work, it gives a warning about &quot;unsafe&quot; constructs. </div></li></ul><div>Limitations</div><div>Because of Java's design choices, there are some limitations of generic programming</div><ul><li><div>Since all kinds of Foo or List are really just the same</div></li><ul><li><div>L.instanceOf(List&lt;String&gt;) will be true with L is a List&lt;Integer&gt;</div></li><li><div>Inside a class (e.g. class Foo) you cannot write new T(), new T[], or x.instanceOf(t)</div></li></ul><li><div>Primitive types are not allowed as type parameters</div></li><ul><li><div>Can't have ArrayList&lt;int&gt;, only ArrayList&lt;Integer&gt;</div></li><li><div>Fortunately, autoboxing and unboxing makes this substitution easy</div></li><li><div>Unfortunately, boxing and unboxing have significant costs associated with them</div></li></ul></ul><div><br/></div></div></span>
</div></body></html> 