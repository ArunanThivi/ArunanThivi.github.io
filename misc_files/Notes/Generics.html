<html>
<head>
  <title>Generics</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="556"/>
<h1>Generics</h1>

<div>
<span><div><div><font style="font-size: 16pt;">The Old Days</font></div><ul><li><div>Java library types (such as <span style="text-decoration: underline;">List</span>) didn't used to parameterized. All <span style="text-decoration: underline;">List</span>s were lists of <span style="text-decoration: underline;">Object</span>s</div></li><li><div>So you'd write things like</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (int i = 0; i &lt; L.size(); i++)</div><div>    { String s = (String) L.get(i); ...}</div></div><ul><li><div>Every Object must be casted so the compiler knows exactly what it is</div></li><li><div>Also, when calling L.add(), there was no check to make sure the parameter was of a valid type</div></li><li><div>Starting with Java 1.5, designers alleviated this problem by introducing <span style="font-weight: bold;">parameterized types</span>, like List&lt;String&gt;</div></li></ul><div><font style="font-size: 16pt;">Basic Parameterization</font></div><ul><li><div>From the definitions of ArrayList and Map in java.util</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class ArrayList&lt;Item&gt; implements List&lt;Item&gt; {</div><div>    public Item get(int i) {...}</div><div>    public boolean add(Item x) {...}</div><div>    ...</div><div>}</div><div>public interface Map&lt;Key, Value&gt; {</div><div>    Value get(Key x);</div><div>    ...</div><div>}</div></div><ul><li><div>Substitute &quot;Item, Key, and Value&quot; in the functions with the type defined when the object is created</div></li></ul><div><font style="font-size: 16pt;">Type Instantiation</font></div><ul><li><div><span style="font-weight: bold;">Instantiating</span> a generic type is analogous to calling a function</div></li><li><div>Consider the ArrayList example from above</div></li><ul><li><div>When we write ArrayList&lt;String&gt; we, in effect, get a new type like</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public String_ArrayList implements List&lt;String&gt; {</div><div>    public String get(int i) {...}</div><div>    public boolean add(String x) {...}</div></div><ul><ul><li><div>Likewise, List&lt;String&gt; refers to a new interface type as well</div></li></ul></ul><div><font style="font-size: 16pt;">Parameters on Methods</font></div><ul><li><div>Functions may ALSO be parameterized by type</div></li><ul><li><div>Example:</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T&gt; List &lt;T&gt; singleton(T item) {...}</div><div>static &lt;T&gt; List&lt;T&gt; emptyList() {...}</div></div><ul><li><div>The compiler figures out <span style="font-style: italic;">T</span> in the expression singleton(x) by looking up the type of <span style="font-style: italic;">x</span>. This is a simple example of <span style="font-weight: bold;">type inference</span></div></li></ul><div><font style="font-size: 16pt;">Wildcards</font></div><ul><li><div>Consider the definition of something that counts the number of tmes something ocurs in a collection of items</div></li><li><div>Could be written as:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T&gt; int frequency(Colelction&lt;T&gt; c, Object x) {</div><div>    int n = 0;</div><div>    for (T y: c) {</div><div>        if (x.equals(y))</div><div>            n ++;</div><div>    }</div><div>    return n;</div><div>}</div></div><ul><li><div>But we really don't care about what <span style="font-style: italic;">T</span> is, so we could just write</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>for (Object y : c) {</div></div><ul><li><div><span style="font-weight: bold;">Wildcard type parameters</span> say that you don't care about what type a parameter is (i.e. it's any subtype of Object)</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int frequency(Collection&lt;?&gt; c, Object x) { ... }</div></div><div><font style="font-size: 16pt;">Sub-typing</font></div><ul><li><div>Consider:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>List&lt;String&gt; LS = new ArrayList&lt;String&gt;();</div><div>List&lt;Object&gt; LObj = LS;</div><div>int[] A = {1, 2};</div><div>LObj.add(A);</div><div>String S = LS.get(0);</div></div><ul><li><div>These commands violate <span style="font-weight: bold;">type safety</span>: the compiler is wrong about the type of a value (an int is in place of a String)</div></li><li><div>For T1&lt;X&gt; to be a subtype of T2&lt;Y&gt;, X == Y</div></li></ul><div><font style="font-size: 12pt;">What about the relationship between T1 and T2?</font></div><ul><li><div>Consider:</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>ArrayList&lt;String&gt; ALS = new ArrayList&lt;String&gt;();</div><div>List&lt;String&gt; LS= ALS;</div></div><ul><li><div>Here, everything is fine</div></li><ul><li><div>The object's dynamic type is ArrayList&lt;String&gt;</div></li><li><div>Thus, the methods expected for LS must be a subset of those for ALS</div></li><li><div>Since the type parameters are the same, the signatures of the methods will be the same</div></li><li><div>Thus, all legal calls on methods of LS will be valid for the actual object pointed to by LS</div></li></ul><li><div>In general, T1&lt;X&gt; is a subtype of T2&lt;X&gt; if T1 is a subtype of T2</div></li></ul><div><font style="font-size: 16pt;">A Java Inconsistency: Arrays</font></div><ul><li><div>As shown above, ArrayList&lt;String&gt; is <span style="font-weight: bold;">not</span> a subtype of ArrayList&lt;Object&gt;, so it is to be expected that String[] is <span style="font-weight: bold;">not</span> a subtype of Object[]</div></li><li><div>However, Java <span style="font-weight: bold;">does</span> have String[] be a subtype of Object[]</div></li><li><div>Java encounters an error like above, it throws a ArrayStoreException (a runtime error) instead of a compile-time error</div></li><li><div>This is done so things like <span style="text-decoration: underline;">ArrayList</span> can be implemented</div></li></ul><div><font style="font-size: 16pt;">Type Bounds</font></div><ul><li><div>Sometimes, the program needs to ensure that a particular type parameters is replaced only by a subtype (or supertype) of a particular type (sort of like specifying the &quot;type of a type&quot;)</div></li><li><div>Example</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class NumericSet&lt;T extends Number&gt; extends HashSet&lt;T&gt; {</div><div>    T min() { ... }</div><div>    ...</div><div>}</div></div><div style="margin-left: 40px;">Requires that all type parameters to NumericSet must be subtypes of Number (the &quot;type bound&quot;). T can either extend or implement the bound as appropriate</div><ul><li><div>Another example</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;T&gt; void fill(List&lt;? super T&gt; L, T x) { ... }</div></div><div style="margin-left: 40px;">means that L can be a List&lt;Q&gt; for any Q as long as T is a subtype of (extends or implements) Q</div><ul><li><div>One more example</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** Search sorted list L for KEY, returning either its position (if present) or k-1, where KEY should be inserted*/</div><div>static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; L, T key)</div></div><ul><li><div>Here, the items of L have to have a type that is comparable to T's, or to have some super-type of T</div></li></ul><div><font style="font-size: 16pt;">Secrets behind the Scenes</font></div><ul><li><div>When you write</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Foo&lt;T&gt; {</div><div>    T x;</div><div>    T.mogrify (T y) { ..}</div><div>}</div></div><div style="margin-left: 40px;">Java is really just giving you</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class Foo {</div><div>    Object x;</div><div>    Object mogrify (Object y) { ... }</div></div><ul><li><div>When you use Generics, Java supplies the casts automatically, and also throws in some additional checks. If it cannot guarantee that all those casts will work, it gives a warning about &quot;unsafe&quot; constructs. </div></li></ul><div><font style="font-size: 16pt;">Limitations</font></div><div>Because of Java's design choices, there are some limitations of generic programming</div><ul><li><div>Since all kinds of Foo or List are really just the same</div></li><ul><li><div>L.instanceOf(List&lt;String&gt;) will be true with L is a List&lt;Integer&gt;</div></li><li><div>Inside a class (e.g. class Foo) you cannot write new T(), new T[], or x.instanceOf(t)</div></li></ul><li><div>Primitive types are not allowed as type parameters</div></li><ul><li><div>Can't have ArrayList&lt;int&gt;, only ArrayList&lt;Integer&gt;</div></li><li><div>Fortunately, autoboxing and unboxing makes this substitution easy</div></li><li><div>Unfortunately, boxing and unboxing have significant costs associated with them</div></li></ul></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 