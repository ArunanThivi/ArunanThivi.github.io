<html>
<head>
  <title>Tree Searching</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="546"/>
<h1>Tree Searching</h1>

<div>
<span><div><div><span style="font-size: 16pt;">Divide and Conquer</span></div><ul><li><div>Much of computation is dovted to finding things in response to various forms of query</div></li><li><div>Linear search for response can be expensive, especially when data set is to large for primary memory</div></li><li><div>It is prerable to have criteria for <span style="font-weight: bold;">dividing</span> data to be searched into pieces recursively</div></li><li><div>I.e. with log <span style="font-style: italic;">N</span> algorithms: at 1 µsecond per comparison, it is possible to process 10<span style="vertical-align: super;">300000</span> items in 1 second</div></li><li><div>Trees are a natural framework for this representation</div></li></ul><div style="margin-left: 40px;"><img src="Tree Searching_files/Image.png" type="image/png" data-filename="Image.png" width="368"/></div><div><span style="font-size: 16pt;">Binary Search Trees</span></div><div><span style="font-size: 14pt;">Binary Search Property</span></div><ul><li><div>Tree nodes contain <span style="font-weight: bold;">keys</span>, and possibly other data</div></li><li><div>All nodes n the <span style="font-weight: bold;">left</span> subtree have <span style="font-weight: bold;">smaller</span> keys</div></li><li><div>All nodes in the <span style="font-weight: bold;">right</span> subtree have <span style="font-weight: bold;">larger</span> keys</div></li></ul><div><font style="font-size: 14pt;">Finding</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static BST find (BST T, Key L) {</div><div>    if (T == null) { return T; }</div><div>    if (L.compareTo(T.label()) == 0){ return T; }</div><div>    else if (L.compareTo(T.label()) &lt; 0){ return find(T.left(), L);</div><div>    else{ return find(T.right(), L);</div></div><ul><li><div>Number of nodes looked at is proportional to the height of the tree</div></li></ul><div><font style="font-size: 14pt;">Inserting</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static BST insert(BST T, Key L) {</div><div>    if (T == null)</div><div>        return new BST(L);</div><div>    if (L.compareTo(T.label()) == 0)</div><div>        T.setLabel(L);</div><div>    else if (L.compareTo(T.label()) &lt; 0)</div><div>        T.setLeft(insert(T.left(), L));</div><div>    else</div><div>        T.setRight(insret(T.right(), L));</div><div>    return T;</div><div>}</div></div><ul><li><div>Time is (once again) proportional to height</div></li></ul><div><font style="font-size: 14pt;">Deletion</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static BST remove(BST T, Key L) {</div><div>    if (T == null)</div><div>        return null;</div><div>    if (L.compareTo(T.label()) == 0) {</div><div>        if (T.left() == null)</div><div>            return T.right();</div><div>        else if (T.right() == null)</div><div>            return T.left();</div><div>        else{</div><div>            Key smallest = minVal(T.right());</div><div>            T.setRight(remove(T.right(), smallest));</div><div>            T.setLabel(smallest);</div><div>        }</div><div>    }</div><div>    else if (L.compareTo(T.label()) &lt; 0)</div><div>        T.setLeft(remove(T.left(), L));</div><div>    else</div><div>        T.setRight(remove(T.right(), L));</div><div>    return T;</div><div>}</div></div><ul><li><div>No children: removes the node and returns the Tree</div></li><li><div>1 child: Switches node with its child and removes the tree with the child removed</div></li><li><div>2 children: Switches the root node with non-min/non-max node and returns the new Tree with the child removed</div></li></ul><div><font style="font-size: 16pt;">More than Two Choices: Quadtrees</font></div><ul><li><div>What if we want to index information about <span style="font-weight: bold;">2D locations</span> so that items can be retrieved by position?</div></li><li><div><span style="font-weight: bold;">Quadtrees</span> do so using standard data-structuring trick: <span style="font-weight: bold;">Divide and Conquer</span></div></li><li><div>Idea: divide (2D) space into four quadrants, and store items in the appropriate quadrant. Repeat this recursively with each quadrant that contains more than one item</div></li><ul><li><div>It's important to not forget items that are in one of the Cardinal Directions (e.g. Due East or Due North)</div></li></ul><li><div>Formal Defintion</div></li><ul><li><div>A quadtree is either</div></li><ul><li><div>Empty, or</div></li><li><div>An item at some position (<span style="font-style: italic;">x, y</span>) called the root PLUS</div></li><li><div>four quadtrees, each containing only items that are NW, NE, SW, or SE of (<span style="font-style: italic;">x, y</span>)</div></li></ul></ul><li><div>The big idea is that if you are looking for point (<span style="font-style: italic;">x'</span>, <span style="font-style: italic;">y'</span>) and the root is not the right point, you can narrow down the possibilities by comparing the current coordinates (<span style="font-style: italic;">x, y</span>) to (<span style="font-style: italic;">x'</span>, <span style="font-style: italic;">y'</span>) </div></li></ul><div><font style="font-size: 16pt;">Point-region (PR) Quadtrees</font></div><ul><li><div>If we use a Quadtree to track <span style="font-weight: bold;">moving</span> objects, it may be useful to be able to <span style="font-weight: bold;">delete</span> items from a tree (when an object moves, the subtree that it goes in may change).</div></li><li><div>This is difficult to do with with the classical data structure above, so we'll deifne instead</div></li><li><div>A quadtree consists of a bounding rectangle, <span style="font-style: italic;">B</span>, and either</div></li><ul><li><div>Zero up to a small number of items that lie in that rectangle <span style="font-weight: bold;">OR</span></div></li><li><div>Four quadtrees whosebounding rectangles are the four quadrants of <span style="font-style: italic;">B</span> (all of equal size)</div></li></ul><li><div>A completely empty quadtree can have an arbitrary bounding rectangle, or you dacn wait for the first point to be inserted. </div></li></ul><div><font style="font-size: 16pt;">Navigating PR Quadtrees</font></div><ul><li><div>To find an item at (<span style="font-style: italic;">x, y</span>) in quadTree T:</div></li></ul><ol><li><div> If (<span style="font-style: italic;">x, y</span>) is outside the bounding rectangle of <span style="font-style: italic;">T</span>, or <span style="font-style: italic;">T</span> is empty, then (<span style="font-style: italic;">x, y</span>) is not in <span style="font-style: italic;">T</span></div></li><li><div>Otherwise, if <span style="font-style: italic;">T</span> contains a small set of items, then (<span style="font-style: italic;">x, y</span>) is in T if and only if it is among these items</div></li><li><div>Otherwise, <span style="font-style: italic;">T</span> consists of four quadtrees. Recursively look for (<span style="font-style: italic;">x, y</span>) in each (all but 1 of these boxes will be rejected by step 1)</div></li></ol><ul><li><div>Similar procedure works when looking for all items within some rectangle <span style="font-style: italic;">R</span></div></li></ul><ol><li><div>If <span style="font-style: italic;">R</span> does not intersect the bounding rectangle of <span style="font-style: italic;">T</span> or <span style="font-style: italic;">T</span> is empty, then there are no items in <span style="font-style: italic;">R</span></div></li><li><div>Otherwise, if <span style="font-style: italic;">T</span> contains a set of items, return those that are in <span style="font-style: italic;">R,</span> if any</div></li><li><div>Otherwise, <span style="font-style: italic;">T</span> consists of four quadtrees. Recursively look for points in <span style="font-style: italic;">R</span> in each one of them</div></li></ol><div><br/></div></div><div><br/></div></span>
</div></body></html> 