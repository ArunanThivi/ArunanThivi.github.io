<html>
<head>
  <title>Tree Searching</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="546"/>
<h1>Tree Searching</h1>

<div>
<span><div><div><font style="font-size: 16pt;">Divide and Conquer</font></div><ul><li><div>Much of computation is dovted to finding things in response to various forms of query</div></li><li><div>Linear search for response can be expensive, especially when data set is to large for primary memory</div></li><li><div>It is prerable to have criteria for <b>dividing</b> data to be searched into pieces recursively</div></li><li><div>I.e. with log <i>N</i> algorithms: at 1 µsecond per comparison, it is possible to process 10<sup>300000</sup> items in 1 second</div></li><li><div>Trees are a natural framework for this representation</div></li></ul><div style="margin-left: 40px;"><img src="Tree Searching_files/Image.png" type="image/png" data-filename="Image.png" width="368"/></div><div><font style="font-size: 16pt;">Binary Search Trees</font></div><div><font style="font-size: 14pt;">Binary Search Property</font></div><ul><li><div>Tree nodes contain <b>keys</b>, and possibly other data</div></li><li><div>All nodes n the <b>left</b> subtree have <b>smaller</b> keys</div></li><li><div>All nodes in the <b>right</b> subtree have <b>larger</b> keys</div></li></ul><div>Finding</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static BST find (BST T, Key L) {</div><div><span>    if (T == null) { return T; }</span><br/></div><div><span><span>    if (L.compareTo(T.label()) == 0){ return T; }</span><br/></span></div><div><span><span>    else if (L.compareTo(T.label()) &lt; 0){ return find(T.left(), L);</span><br/></span></div><div><span><span>    else{ return find(T.right(), L);</span><br/></span></div></div><ul><li><div>Number of nodes looked at is proportional to the height of the tree</div></li></ul><div>Inserting</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static BST insert(BST T, Key L) {</div><div><span>    if (T == null)</span><br/></div><div><span><span>    </span><span>    return new BST(L);</span><br/></span></div><div><span><span>    if (L.compareTo(T.label()) == 0)</span><br/></span></div><div><span><span>    </span><span>    T.setLabel(L);</span><br/></span></div><div><span><span>    else if (L.compareTo(T.label()) &lt; 0)</span><br/></span></div><div><span><span>    </span><span>    T.setLeft(insert(T.left(), L));</span><br/></span></div><div><span><span>    else</span><br/></span></div><div><span><span>    </span><span>    T.setRight(insret(T.right(), L));</span><br/></span></div><div><span><span>    return T;</span><br/></span></div><div><span>}</span></div></div><ul><li><div>Time is (once again) proportional to height</div></li></ul><div>Deletion</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static BST remove(BST T, Key L) {</div><div><span>    if (T == null)</span><br/></div><div><span><span>    </span><span>    return null;</span><br/></span></div><div><span><span>    if (L.compareTo(T.label()) == 0) {</span><br/></span></div><div><span><span>    </span><span>    if (T.left() == null)</span><br/></span></div><div><span><span>    </span><span>    </span><span>    return T.right();</span><br/></span></div><div><span><span>    </span><span>    else if (T.right() == null)</span><br/></span></div><div><span><span>    </span><span>    </span><span>    return T.left();</span><br/></span></div><div><span><span>    </span><span>    else{</span><br/></span></div><div><span><span>    </span><span>    </span><span>    Key smallest = minVal(T.right());</span><br/></span></div><div><span><span>    </span><span>    </span><span>    T.setRight(remove(T.right(), smallest));</span><br/></span></div><div><span><span>    </span><span>    </span><span>    T.setLabel(smallest);</span><br/></span></div><div><span><span>    </span><span>    }</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span><span>    else if (L.compareTo(T.label()) &lt; 0)</span><br/></span></div><div><span><span>    <span>    T.setLeft(remove(T.left(), L));</span></span><br/></span></div><div><span><span>    else</span><br/></span></div><div><span><span>    </span><span>    T.setRight(remove(T.right(), L));</span><br/></span></div><div><span><span>    return T;</span><br/></span></div><div><span>}</span></div></div><ul><li><div>No children: removes the node and returns the Tree</div></li><li><div>1 child: Switches node with its child and removes the tree with the child removed</div></li><li><div>2 children: Switches the root node with non-min/non-max node and returns the new Tree with the child removed</div></li></ul><div>More than Two Choices: Quadtrees</div><ul><li><div>What if we want to index information about <b>2D locations</b> so that items can be retrieved by position?</div></li><li><div><b>Quadtrees</b> do so using standard data-structuring trick: <b>Divide and Conquer</b></div></li><li><div>Idea: divide (2D) space into four quadrants, and store items in the appropriate quadrant. Repeat this recursively with each quadrant that contains more than one item</div></li><ul><li><div>It's important to not forget items that are in one of the Cardinal Directions (e.g. Due East or Due North)</div></li></ul><li><div>Formal Defintion</div></li><ul><li><div>A quadtree is either</div></li><ul><li><div>Empty, or</div></li><li><div>An item at some position (<i>x, y</i>) called the root PLUS</div></li><li><div>four quadtrees, each containing only items that are NW, NE, SW, or SE of (<i>x, y</i>)</div></li></ul></ul><li><div>The big idea is that if you are looking for point (<i>x'</i>, <i>y'</i>) and the root is not the right point, you can narrow down the possibilities by comparing the current coordinates (<i>x, y</i>) to (<span style="font-style: italic;">x'</span>, <span style="font-style: italic;">y'</span>) </div></li></ul><div>Point-region (PR) Quadtrees</div><ul><li><div>If we use a Quadtree to track <b>moving</b> objects, it may be useful to be able to <b>delete</b> items from a tree (when an object moves, the subtree that it goes in may change).</div></li><li><div>This is difficult to do with with the classical data structure above, so we'll deifne instead</div></li><li><div>A quadtree consists of a bounding rectangle, <i>B</i>, and either</div></li><ul><li><div>Zero up to a small number of items that lie in that rectangle <b>OR</b></div></li><li><div>Four quadtrees whosebounding rectangles are the four quadrants of <i>B</i> (all of equal size)</div></li></ul><li><div>A completely empty quadtree can have an arbitrary bounding rectangle, or you dacn wait for the first point to be inserted. </div></li></ul><div>Navigating PR Quadtrees</div><ul><li><div>To find an item at (<i>x, y</i>) in quadTree T:</div></li></ul><ol><li><div> If (<i>x, y</i>) is outside the bounding rectangle of <i>T</i>, or <i>T</i> is empty, then (<span style="font-style: italic;">x, y</span>) is not in <i>T</i></div></li><li><div>Otherwise, if <i>T</i> contains a small set of items, then (<span style="font-style: italic;">x, y</span>) is in T if and only if it is among these items</div></li><li><div>Otherwise, <i>T</i> consists of four quadtrees. Recursively look for (<span style="font-style: italic;">x, y</span>) in each (all but 1 of these boxes will be rejected by step 1)</div></li></ol><ul><li><div>Similar procedure works when looking for all items within some rectangle <i>R</i></div></li></ul><ol><li><div>If <i>R</i> does not intersect the bounding rectangle of <i>T</i> or <i>T</i> is empty, then there are no items in <i>R</i></div></li><li><div>Otherwise, if <i>T</i> contains a set of items, return those that are in <i>R,</i> if any</div></li><li><div>Otherwise, <i>T</i> consists of four quadtrees. Recursively look for points in <i>R</i> in each one of them</div></li></ol><div><br/></div></div></span>
</div></body></html> 