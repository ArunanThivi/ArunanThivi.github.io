<html>
<head>
  <title>Trees</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="542"/>
<h1>Trees</h1>

<div>
<span><div><div><font style="font-size: 16pt;">Trees</font></div><ul><li><div><b>Trees</b> naturally represent recursively defined, hierarchical objects with more than one recursive sub-part for each instance</div></li><li><div>Common Examples: expressions, sentences</div></li><li><div>Trees also describe structures which can be recursively divided into multiple subsets</div></li></ul><div><font style="font-size: 16pt;">Formal Definitions</font></div><ul><li><div><b>CS 61a Style</b> - A tree consists of a <b>label</b> value and zero or more <b>branches</b> (or <b>children</b>), each of them a tree</div></li><li><div><b>CS 61a Style (Alt)</b> - A tree is a set of <b>nodes</b> (or <b>vertices</b>), each of which has a label value and one or more <b>child</b> <b>nodes</b>, such that no node descends (directly or indirectly) from itself. A node is the <b>parent</b> of its children.</div></li><li><div><b>Positional Trees</b> - A tree is either <b>empty</b> or consists of a node containing a label value and an indexed sequence of zero or more children, each a positional tree. If every node has two positions, we have a <b>binary tree</b> and the children are its <b>left and right sub-trees</b>. </div></li></ul><div>Tree Characteristics</div><ul><li><div>The <b>root</b> of a tree is a non-empty node with no parent in that tree (its parent might be in some larger three that ocntains that tree as a substree). Thus, every node is the root of a (sub)tree.</div></li><li><div>The <b>order</b>, <b>arity,</b> or <b>degree</b> of a node is its number (max number) of children</div></li><li><div>The nodes of a <b>k-ary</b> <b>tree</b> have at most k children</div></li><li><div>A <b>leaf</b> node has no children (no non-empty children in the case of positional trees)</div></li><li><div>The <b>height</b> of a node in a tree is the largest distance to a leaf. A leaf has height 0 and the max height of a tree is equal to the height of its root</div></li><li><div>The <b>depth</b> of a node in a tree is the distance to the root of that tree. The root node has depth 0 and node S where S != R, the depth of R is 1 more than its parent</div></li></ul><div><font style="font-size: 16pt;">Traversal</font></div><ul><li><div><b>Traversing a tree</b> means enumerating (some subset of) its nodes</div></li><li><div>Typically done <b>recursively</b>, because that is natural description</div></li><li><div>As nodes are enumerated, we say that they are <b>visted</b></div></li><li><div>Three basic orders for enumeration</div></li><ul><li><div>Preorder: visit node, traverse its children</div></li><li><div>Postorder: traverse children, visit node</div></li><li><div>Inorder: traverse first child, visit node, traverse second child (binary trees only)</div></li></ul></ul><div><img src="Trees_files/Image.png" type="image/png" data-filename="Image.png" width="531"/></div><div><font style="font-size: 16pt;">General Traversal</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void preorderTraverse(Tree&lt;Label&gt; T, Consumer&lt;Tree&lt;Label&gt;&gt; visit) {</div><div><span>    if (T != null) {</span><br/></div><div><span><span>    </span><span>    visit.accept(T);</span><br/></span></div><div><span><span>    </span><span>    for (int i = 0; i &lt; T.arity(); i++)</span><br/></span></div><div><span><span>    </span><span>    </span><span>    preorderTraverse(T.child(i), visit);</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span>}</span></div><div><span><br/></span></div><div><span>preorderTraverse(myTree, T -&gt; System.out.print(T.label() + &quot; &quot;));      //Java 8 lambda syntax</span></div></div><div><font style="font-size: 16pt;"><br/></font></div><div><font style="font-size: 16pt;">Iterative Depth-First Traversal</font></div><ul><li><div>Tree recursion conceals data: a <b>stack</b> of nodes and a little extra information, this data can be made explicit</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void preorderTraverse2(Tree&lt;Label&gt; T, Consumer&lt;Tree&lt;Label&gt;&gt; visit) {</div><div><span>    Stack&lt;Tree&lt;Label&gt;&gt; work = new Stack&lt;&gt;();</span><br/></div><div><span><span>    work.push(T);</span><br/></span></div><div><span><span>    while (!work.isEmpty()) {</span><br/></span></div><div><span><span>    </span><span>    Tree&lt;Label&gt; node = work.pop();</span><br/></span></div><div><span><span>    </span><span>    visit.accept(node);</span><br/></span></div><div><span><span>    </span><span>    for (int i = node.arity() - 1; i &gt;= 0; i--) {</span><br/></span></div><div><span><span>    </span><span>    </span><span>    work.push(node.child(i));</span><br/></span></div></div><ul><li><div>This traversal takes the same time and space as the recursive solution</div></li><li><div>We have built an explicit stack data structure for Java's built-in execution stack (which handles function calls)</div></li><li><div>For loop works backwards so that the last node in (left-most) is the first node out</div></li></ul><div><font style="font-size: 16pt;">Breadth-first Traversal</font></div><ul><li><div><font style="font-size: 10pt;">Traverse all nodes at depth 0, then depth 1, etc.</font></div></li><li><div>change Iterative Depth-first traversal from LIFO to FIFO</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void breadthFirstTraverse(Tree&lt;Label&gt; T, Consumer&lt;Tree&lt;Label&gt;&gt; visit) {</div><div><span>    ArrayDeque&lt;Tree&lt;Label&gt;&gt; work = new ArrayDeque&lt;&gt;();   //Changed</span><br/></div><div><span><span>    work.push(T);</span><br/></span></div><div><span><span>    while (!work.isEmpty()) {</span><br/></span></div><div><span>    </span><span>    Tree&lt;Label&gt; node = work.remove();</span>   //Changed</div><div><span><span>    </span><span>    if (node != null) {</span><br/></span></div><div><span><span>    </span><span>    </span><span>    visit.accept(node);</span><br/></span></div><div><span>    </span><span>    </span><span>    for (int i = 0; i &lt; node.arity(); i++) </span>   //Changed</div><div><span><span>    </span><span>    </span><span>    </span><span>    work.push(node.child(i));</span><br/></span></div><div><span><span>    <span>    }</span></span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span>}</span></div></div><div>Recursive  Breadth-First Traversal: Iterative Deepening</div><ul><li><div>Previous breadth-first traversal used space proportional to the <b>width</b> of the tree, which is Θ(<i>N</i>) for bushy trees, whereas depth-first traversal takes log <i>N</i> space on bushy trees</div></li><li><div>Is is possible to get breadth-first traversal in log <i>N</i> space and Θ(<span style="font-style: italic;">N</span>) time on bushy trees?</div></li><li><div>For each level, <i>k</i>, of the tree from 0 to <b>lev</b>, call doLevel (T, k):</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void doLevel(Tree T, int lev) {</div><div><span>    if (lev == 0)</span><br/></div><div><span><span>    </span><span>    visit T</span><br/></span></div><div><span><span>    else</span><br/></span></div><div><span><span>    </span><span>    for each non-null child, C, of T {</span><br/></span></div><div><span><span>    </span><span>    </span><span>    doLevel(C, lev-1);</span><br/></span></div><div><span><span>    </span><span>    }</span><br/></span></div><div><span>}</span></div></div><ul><li><div>So we do breadth-first traversal by repeated (truncated) depth-first traversals: <b>iterative deepening</b>.</div></li><li><div>In doLevel(T, k), we skip (traverse but don't visit) the nodes before level <i>k</i>, and then visit at level <i>k</i>, but not their children</div></li></ul><div>Times</div><ul><li><div>Tree traversal is <b>linear</b> Θ(<i>N</i>) where <i>N</i> is the # of nodes: Form of the algorithm implies that there is one vist at the root, and then one visit for every <b>edge</b> in the tree. Since every node but the root has exactly one parent, and the root has none, there MUST be N - 1 edges in any non-empty tree.</div></li><li><div>In a positional tree, there is also one recursive call for each empty tree, but # of empty trees can be no grater than <i>kN</i> where <i>k</i> is arity</div></li><li><div>For any tree of arity <i>k</i>, <i>h</i> + 1 &lt;= <i>N</i> &lt;= (<i>k</i><sup><i>h</i> + 1</sup>- 1) / (<i>k</i> - 1) where <i>h</i> is the height of the tree</div></li><li><div>So h ⋲Ω(log<sub>k</sub> <i>N</i>) = Ω(log <i>N</i>) and ⋲ <i>O</i>(<i>N</i>).</div></li><li><div>Many tree algorithms look at one child only. For them, the worst-case time is proportional to the <b>height</b> of the tree Θ(log <i>N</i>) (assuming that the tree is <b>bushy</b> (each level has as many nodes as possible)</div></li></ul><div>Iterators for Trees</div><ul><li><div>Iterators are <b>NOT</b> convenient on Trees</div></li><li><div>However, iterative methods can be used</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class PreorderTreeIterator&lt;Label&gt; implements Iterator&lt;Label&gt; {</div><div><span>    private Stack&lt;Tree&lt;Label&gt;&gt; s = new Stack&lt;Tree&lt;Label&gt;&gt;();</span><br/></div><div><span><span>    public PreorderTreeIterator(Tree&lt;Label&gt; T) { s.push(T);</span><br/></span></div><div><span><span>    </span><span>public boolean hasNext() { return !s.isEmpty(); }</span><br/></span></div><div><span><span>    public T next() {</span><br/></span></div><div><span><span>    </span><span>    Tree&lt;Label&gt; result = s.pop();</span><br/></span></div><div><span><span>    </span><span>    for (int i = result.arity()-1; i &gt;= 0; i--)</span><br/></span></div><div><span><span>    </span><span>    </span><span>    s.push(result.child(i));</span><br/></span></div><div><span><span>    </span><span>    return result.label();</span><br/></span></div><div><span><span>    }</span><br/></span></div><div><span>}</span></div><div><span><br/></span></div><div><span>for (String label : aTree) System.out.println(label + &quot; &quot;);</span></div></div><ul><li><div>This is similar to the Iterative Depth-First traversal</div></li></ul><div><br/></div></div></span>
</div></body></html> 