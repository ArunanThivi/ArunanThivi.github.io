<html>
<head>
  <title>Trees</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308919 (en-US, MWS); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="542"/>
<h1>Trees</h1>

<div>
<span><div><div><font style="font-size: 24pt;">Trees</font></div><ul><li><div><span style="font-weight: bold;">Trees</span> naturally represent recursively defined, hierarchical objects with more than one recursive sub-part for each instance</div></li><li><div>Common Examples: expressions, sentences</div></li><li><div>Trees also describe structures which can be recursively divided into multiple subsets</div></li></ul><div><span style="font-size: 16pt;">Formal Definitions</span></div><ul><li><div><span style="font-weight: bold;">CS 61a Style</span> - A tree consists of a <span style="font-weight: bold;">label</span> value and zero or more <span style="font-weight: bold;">branches</span> (or <span style="font-weight: bold;">children</span>), each of them a tree</div></li><li><div><span style="font-weight: bold;">CS 61a Style (Alt)</span> - A tree is a set of <span style="font-weight: bold;">nodes</span> (or <span style="font-weight: bold;">vertices</span>), each of which has a label value and one or more <span style="font-weight: bold;">child</span> <span style="font-weight: bold;">nodes</span>, such that no node descends (directly or indirectly) from itself. A node is the <span style="font-weight: bold;">parent</span> of its children.</div></li><li><div><span style="font-weight: bold;">Positional Trees</span> - A tree is either <span style="font-weight: bold;">empty</span> or consists of a node containing a label value and an indexed sequence of zero or more children, each a positional tree. If every node has two positions, we have a <span style="font-weight: bold;">binary tree</span> and the children are its <span style="font-weight: bold;">left and right sub-trees</span>. </div></li></ul><div><font style="font-size: 16pt;">Tree Characteristics</font></div><ul><li><div>The <span style="font-weight: bold;">root</span> of a tree is a non-empty node with no parent in that tree (its parent might be in some larger three that ocntains that tree as a substree). Thus, every node is the root of a (sub)tree.</div></li><li><div>The <span style="font-weight: bold;">order</span>, <span style="font-weight: bold;">arity,</span> or <span style="font-weight: bold;">degree</span> of a node is its number (max number) of children</div></li><li><div>The nodes of a <span style="font-weight: bold;">k-ary</span> <span style="font-weight: bold;">tree</span> have at most k children</div></li><li><div>A <span style="font-weight: bold;">leaf</span> node has no children (no non-empty children in the case of positional trees)</div></li><li><div>The <span style="font-weight: bold;">height</span> of a node in a tree is the largest distance to a leaf. A leaf has height 0 and the max height of a tree is equal to the height of its root</div></li><li><div>The <span style="font-weight: bold;">depth</span> of a node in a tree is the distance to the root of that tree. The root node has depth 0 and node S where S != R, the depth of R is 1 more than its parent</div></li></ul><div><span style="font-size: 16pt;">Traversal</span></div><ul><li><div><span style="font-weight: bold;">Traversing a tree</span> means enumerating (some subset of) its nodes</div></li><li><div>Typically done <span style="font-weight: bold;">recursively</span>, because that is natural description</div></li><li><div>As nodes are enumerated, we say that they are <span style="font-weight: bold;">visted</span></div></li><li><div>Three basic orders for enumeration</div></li><ul><li><div>Preorder: visit node, traverse its children</div></li><li><div>Postorder: traverse children, visit node</div></li><li><div>Inorder: traverse first child, visit node, traverse second child (binary trees only)</div></li></ul></ul><div><img src="Trees_files/Image.png" type="image/png" data-filename="Image.png" width="531"/></div><div><span style="font-size: 16pt;">General Traversal</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void preorderTraverse(Tree&lt;Label&gt; T, Consumer&lt;Tree&lt;Label&gt;&gt; visit) {</div><div>    if (T != null) {</div><div>        visit.accept(T);</div><div>        for (int i = 0; i &lt; T.arity(); i++)</div><div>            preorderTraverse(T.child(i), visit);</div><div>    }</div><div>}</div><div><br/></div><div>preorderTraverse(myTree, T -&gt; System.out.print(T.label() + &quot; &quot;));      //Java 8 lambda syntax</div></div><div><font style="font-size: 16pt;"><br/></font></div><div><span style="font-size: 16pt;">Iterative Depth-First Traversal</span></div><ul><li><div>Tree recursion conceals data: a <span style="font-weight: bold;">stack</span> of nodes and a little extra information, this data can be made explicit</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void preorderTraverse2(Tree&lt;Label&gt; T, Consumer&lt;Tree&lt;Label&gt;&gt; visit) {</div><div>    Stack&lt;Tree&lt;Label&gt;&gt; work = new Stack&lt;&gt;();</div><div>    work.push(T);</div><div>    while (!work.isEmpty()) {</div><div>        Tree&lt;Label&gt; node = work.pop();</div><div>        visit.accept(node);</div><div>        for (int i = node.arity() - 1; i &gt;= 0; i--) {</div><div>            work.push(node.child(i));</div></div><ul><li><div>This traversal takes the same time and space as the recursive solution</div></li><li><div>We have built an explicit stack data structure for Java's built-in execution stack (which handles function calls)</div></li><li><div>For loop works backwards so that the last node in (left-most) is the first node out</div></li></ul><div><span style="font-size: 16pt;">Breadth-first Traversal</span></div><ul><li><div><span style="font-size: 10pt;">Traverse all nodes at depth 0, then depth 1, etc.</span></div></li><li><div>change Iterative Depth-first traversal from LIFO to FIFO</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void breadthFirstTraverse(Tree&lt;Label&gt; T, Consumer&lt;Tree&lt;Label&gt;&gt; visit) {</div><div>    ArrayDeque&lt;Tree&lt;Label&gt;&gt; work = new ArrayDeque&lt;&gt;();   //Changed</div><div>    work.push(T);</div><div>    while (!work.isEmpty()) {</div><div>        Tree&lt;Label&gt; node = work.remove();   //Changed</div><div>        if (node != null) {</div><div>            visit.accept(node);</div><div>            for (int i = 0; i &lt; node.arity(); i++)    //Changed</div><div>                work.push(node.child(i));</div><div>        }</div><div>    }</div><div>}</div></div><div>Recursive  Breadth-First Traversal: Iterative Deepening</div><ul><li><div>Previous breadth-first traversal used space proportional to the <span style="font-weight: bold;">width</span> of the tree, which is Θ(<span style="font-style: italic;">N</span>) for bushy trees, whereas depth-first traversal takes log <span style="font-style: italic;">N</span> space on bushy trees</div></li><li><div>Is is possible to get breadth-first traversal in log <span style="font-style: italic;">N</span> space and Θ(<span style="font-style: italic;">N</span>) time on bushy trees?</div></li><li><div>For each level, <span style="font-style: italic;">k</span>, of the tree from 0 to <span style="font-weight: bold;">lev</span>, call doLevel (T, k):</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>void doLevel(Tree T, int lev) {</div><div>    if (lev == 0)</div><div>        visit T</div><div>    else</div><div>        for each non-null child, C, of T {</div><div>            doLevel(C, lev-1);</div><div>        }</div><div>}</div></div><ul><li><div>So we do breadth-first traversal by repeated (truncated) depth-first traversals: <span style="font-weight: bold;">iterative deepening</span>.</div></li><li><div>In doLevel(T, k), we skip (traverse but don't visit) the nodes before level <span style="font-style: italic;">k</span>, and then visit at level <span style="font-style: italic;">k</span>, but not their children</div></li></ul><div><font style="font-size: 16pt;">Times</font></div><ul><li><div>Tree traversal is <span style="font-weight: bold;">linear</span> Θ(<span style="font-style: italic;">N</span>) where <span style="font-style: italic;">N</span> is the # of nodes: Form of the algorithm implies that there is one vist at the root, and then one visit for every <span style="font-weight: bold;">edge</span> in the tree. Since every node but the root has exactly one parent, and the root has none, there MUST be N - 1 edges in any non-empty tree.</div></li><li><div>In a positional tree, there is also one recursive call for each empty tree, but # of empty trees can be no grater than <span style="font-style: italic;">kN</span> where <span style="font-style: italic;">k</span> is arity</div></li><li><div>For any tree of arity <span style="font-style: italic;">k</span>, <span style="font-style: italic;">h</span> + 1 &lt;= <span style="font-style: italic;">N</span> &lt;= (<span style="font-style: italic;">k</span><span style="vertical-align: super; font-style: italic;">h</span><span style="vertical-align: super;"> + 1</span>- 1) / (<span style="font-style: italic;">k</span> - 1) where <span style="font-style: italic;">h</span> is the height of the tree</div></li><li><div>So h ⋲Ω(log<span style="vertical-align: sub;">k</span> <span style="font-style: italic;">N</span>) = Ω(log <span style="font-style: italic;">N</span>) and ⋲ <span style="font-style: italic;">O</span>(<span style="font-style: italic;">N</span>).</div></li><li><div>Many tree algorithms look at one child only. For them, the worst-case time is proportional to the <span style="font-weight: bold;">height</span> of the tree Θ(log <span style="font-style: italic;">N</span>) (assuming that the tree is <span style="font-weight: bold;">bushy</span> (each level has as many nodes as possible)</div></li></ul><div><font style="font-size: 16pt;">Iterators for Trees</font></div><ul><li><div>Iterators are <span style="font-weight: bold;">NOT</span> convenient on Trees</div></li><li><div>However, iterative methods can be used</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class PreorderTreeIterator&lt;Label&gt; implements Iterator&lt;Label&gt; {</div><div>    private Stack&lt;Tree&lt;Label&gt;&gt; s = new Stack&lt;Tree&lt;Label&gt;&gt;();</div><div>    public PreorderTreeIterator(Tree&lt;Label&gt; T) { s.push(T);</div><div>    public boolean hasNext() { return !s.isEmpty(); }</div><div>    public T next() {</div><div>        Tree&lt;Label&gt; result = s.pop();</div><div>        for (int i = result.arity()-1; i &gt;= 0; i--)</div><div>            s.push(result.child(i));</div><div>        return result.label();</div><div>    }</div><div>}</div><div><br/></div><div>for (String label : aTree) System.out.println(label + &quot; &quot;);</div></div><ul><li><div>This is similar to the Iterative Depth-First traversal</div></li></ul><div><br/></div></div><div><br/></div></span>
</div></body></html> 